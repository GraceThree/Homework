\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{microtype}
\usetikzlibrary{quantikz}

\author{Grace Unger}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\author{Grace Unger}
\title{Quantum Algorithms Homework}
\def\NN{\mathbb{N}}
\def\ZZ{\mathbb{Z}}
\def\RR{\mathbb{R}}
\def\QQ{\mathbb{Q}}
\def\CC{\mathbb{C}}
\def\KK{\mathbb{K}}
\def\note{\text{NOT}}

\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\R{\mathbb{R}}
\def\Q{\mathbb{Q}}
\def\C{\mathbb{C}}
\def\K{\mathbb{K}}


\def\cA{\mathcal{A}}
\def\cB{\mathcal{B}}
\def\cC{\mathcal{C}}
\def\cF{\mathcal{F}}
\def\cH{\mathcal{H}}
\def\cL{\mathcal{L}}
\def\cN{\mathcal{N}}
\def\cO{\mathcal{O}}
\def\cP{\mathcal{P}}
\def\cR{\mathcal{R}}
\def\cS{\mathcal{S}}

\def\ee{\varepsilon}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{enumerate}
    \item Draw the $n$-variable Deustch Oracle circuit. \smallskip
    
    It is clear to see that this is given by:

    \begin{quantikz}
        \lstick{\ket{0}} &\gate{H} \qwbundle[alternate=3]{}  &
         \ctrlbundle{1} & \gate{H} \qwbundle[alternate=3]{} & \meter{}\qwbundle[alternate=3]{} \\
        \lstick{\ket{1}}& \gate{H} \qw &
         \gate{U_f} & \gate{H} \qw &\meter{}
    \end{quantikz}

    where the input $\ket{0}$ is understood to mean $\ket{0}^{\otimes n}, $ and $U_f$ is the function to be tested. 
    \item Realize a full adder using:
        \begin{enumerate}
            \item Decoders and OR gates
            \item Reversible logic
            \item Multiplexers, with 1 address variable
            \item Arbitrary multiplexers
        \end{enumerate}\smallskip

        \begin{enumerate}
            \item  This is attached separately, because making classical circuits in latex is way worse than quantum.\smallskip

            \item This is given by:
                
            \begin{quantikz}
                \lstick{$I_0$} & \octrl{2}  & \ctrl{1} &  \ctrl{2}\qw & \ctrl{1}\qw & \rstick{$I_0$}\qw\\
                \lstick{$I_1$}& \octrl{1} & \targ \qw& \ctrl{1}\qw &\targ\qw & \targ \qw &  \ctrl{1}\qw & \targ \qw &\rstick{$C_{new}$}\qw\\
                \lstick{$0$} & \targ \qw  & \qw & \targ\qw & \qw &\ctrl{-1}\qw & \targ\qw & \ctrl{-1}\qw &\rstick{$Out$}\qw\\
                \lstick{$C_{old}$} & \ctrl{-1} & \ctrl{-2} & \octrl{-1} & \octrl{-2} & \octrl{-1} & \octrl{-1} & \octrl{-1} & \rstick{$C_{old}$}\qw\\
            \end{quantikz}\smallskip

            This runs on a single ancilla, at the cost of having to do a CSWAP at the end to get the outputs and carries in the right spots. I don't expect there to be a no ancillae solution since we have a product or sum no matter what.
        \end{enumerate}
    \item Realize the functions:
        \begin{enumerate}
            \item $f = ab + a'c$ using reversible logic
            \item $f = abc + de'f' + a'b'c' + d'f$ with multiplexers
        \end{enumerate}
        \begin{enumerate}
            \item We get:
        \end{enumerate}
    \item Implement the 3x3 majority gate in an efficient way.
    \begin{proof}
        We do this by taking a spectral decomposition of the majority function. The attached FPRMSpectrum.py python file takes the Karnaugh map of an arbitrary $n$ variable function and returns the spectrum of minimal cost. Of course, we could also just take this since it's not very hard to compute, but this approach generalizes well. We get a spectrum of \[\begin{pmatrix}
            0 & 0 & 0 &1 & 0 &1 & 1 & 0
        \end{pmatrix}\]
        which is equivalent to $ab\oplus bc \oplus ca.$
    \end{proof}
\end{enumerate}
\end{document}